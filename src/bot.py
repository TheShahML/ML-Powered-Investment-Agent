from loguru import logger
from src.config import load_config
from src.data_service import DataService
from src.feature_engineering import FeatureEngineer
from src.strategy_ml import MLStrategy
from src.execution_service import ExecutionService
from src.database import get_engine, get_session, init_db
from src.models import Run, Signal, TargetWeight, Order
from src.integrations.qlib_client import QlibClient
import datetime
import time

class InvestingBot:
    def __init__(self, dry_run=False):
        self.config = load_config()
        self.dry_run = dry_run
        self.engine = get_engine()
        init_db(self.engine)
        
        self.data_service = DataService(self.config)
        self.feature_engineer = FeatureEngineer(self.config)
        self.ml_strategy = MLStrategy(self.config)
        self.execution_service = ExecutionService(self.config)
        self.qlib_client = QlibClient(self.engine)

    def run_weekly_rebalance(self):
        session = get_session(self.engine)
        run = Run(run_type='rebalance', status='in_progress')
        session.add(run)
        session.commit()
        
        try:
            logger.info(f"Starting weekly rebalance run (ID: {run.id}, Dry Run: {self.dry_run})")
            
            # 1. Check idempotency
            # ...
            
            # 2. Get Signals from Postgres (generated by Qlib scoring)
            logger.info("Fetching latest signals from Postgres...")
            signals = self.qlib_client.get_latest_signals()
            
            if signals.empty:
                logger.warning("No signals found in DB. Falling back to native ML strategy computation.")
                # Fallback to old behavior for robustness
                today = datetime.date.today()
                yesterday = today - datetime.timedelta(days=1)
                universe = self.data_service.get_universe()
                start_date = (today - datetime.timedelta(days=365)).strftime('%Y-%m-%d')
                end_date = yesterday.strftime('%Y-%m-%d')
                df = self.data_service.get_historical_data(universe, start_date, end_date)
                df_features = self.feature_engineer.compute_features(df)
                signals = self.ml_strategy.compute_signals(df_features)
                
                # Log these fallback signals
                for ticker, row in signals.iterrows():
                    sig = Signal(
                        run_id=run.id,
                        date=datetime.datetime.combine(yesterday, datetime.time()),
                        ticker=ticker,
                        score=float(row['score']),
                        rank=int(row['rank'])
                    )
                    session.add(sig)
            
            # 3. Portfolio Construction & Constraints
            top_n = signals.head(self.config['n_holdings'])
            target_weight = 1.0 / self.config['n_holdings']
            max_weight = self.config.get('max_position_weight', 0.12)
            final_weight = min(target_weight, max_weight)
            
            target_weights = {ticker: final_weight for ticker in top_n.index}
            
            # Log target weights
            for ticker, weight in target_weights.items():
                tw = TargetWeight(run_id=run.id, date=datetime.datetime.now(), ticker=ticker, weight=weight)
                session.add(tw)
                
            # 5. Execution
            self.execution_service.execute_rebalance(target_weights, dry_run=self.dry_run)
            
            run.status = 'success'
            run.completed_at = datetime.datetime.utcnow()
            logger.info("Weekly rebalance completed successfully.")
            
        except Exception as e:
            logger.exception(f"Error during rebalance: {e}")
            run.status = 'failed'
            run.error_message = str(e)
            run.completed_at = datetime.datetime.utcnow()
        finally:
            session.commit()
            session.close()

if __name__ == "__main__":
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument("--dry-run", action="store_true", help="Run without placing orders")
    parser.add_argument("--mode", choices=['rebalance', 'heartbeat'], default='rebalance')
    args = parser.parse_args()
    
    bot = InvestingBot(dry_run=args.dry_run)
    if args.mode == 'rebalance':
        bot.run_weekly_rebalance()

